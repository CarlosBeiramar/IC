% Specification for the rope bridge problem
% (based on Bas Ploeger, 2008)

% Adventurers are identified by their "speeds", i.e. the number of
% minutes they need for crossing the bridge. For this we use the basic
% integer data type of mCRL2 called 'Int'.

% Data type for the position of adventurers and the flashlight.
% Initially, they are all on the 'start' side of the bridge. In the end,
% they should all have reached the 'finish' side.
sort Position = struct start | finish;


act 
    % Action declarations:
    % - 'forward'  means:  from start to finish
    % - 'back'     means:  from finish to start

    % The flashlight moves forward together with two adventurers,
    % identified by the action's parameters.
    forward_flashlight: Int # Int;

    % The flashlight moves back together with one adventurer, identified
    % by the action's parameter.
    back_flashlight: Int;


%%% TODO (Exercise 1): 
%%% Add action declarations for Adventurer process here

	forward_adventurer: Int # Int;   % speed and time of adenturer
	back_adventurer: Int;

%%% TODO (Exercise 2):
%%% Add action declarations for synchronised events.
	forward: Int # Int;
	back: Int;	


%%% TODO (Exercise 5):
%%% Add action declarations for Referee process.
	forward_referee: Int # Int;
	back_referee: Int;

	report: Int;

% The Flashlight process models the flashlight:
% 1. If it is at the 'start' side, it can move forward together with any
%    pair of adventurers.
% 2. If it is at the 'finish' side, it can move back together with any
%    adventurer.
proc Flashlight(pos:Position) =
       (pos == start) ->
         % Case 1.
         sum s,s':Int . forward_flashlight(s,s') . Flashlight(finish)
       <> 
         % Case 2.
         sum s:Int . back_flashlight(s) . Flashlight(start);


%%% TODO (Exercise 1):
%%% Add Adventurer process definition here
proc Adventurer(speed:Int, pos:Position)=
		(pos == start) -> 
		sum s:Int . 
		(s > speed) -> forward_adventurer (speed,s) . Adventurer(speed, finish)
						<>	forward_adventurer(s,speed). Adventurer(speed,finish) 
		<>
		back_adventurer(speed) . Adventurer(speed, start); 

%%% TODO (Exercise 5):
%%% Add Referee process definition here

proc Referee (minutes:Int, num_finished:Int)=
	sum s,s': Int . forward_referee(s,s').Referee(minutes + max(s,s'), num_finished +2)
	+
	(num_finished < 4) -> sum s:Int . back_referee(s) . Referee(minutes + s, num_finished - 1)
						  <>
							report(minutes). Referee(minutes,num_finished);
		



% Initial process definition: the system currently only consists of a
% flashlight at the 'start' side.
init
  allow({forward, back,report},
   comm({forward_adventurer | forward_adventurer | forward_flashlight | forward_referee
            -> forward,
         back_adventurer | back_flashlight | back_referee -> back},
       Adventurer(1,start) || Adventurer(2,start)  || 
       Adventurer(5,start) || Adventurer(10,start) || 
       Flashlight(start) || Referee(0,0)
     ));
%%% TODO (Exercise 2):
%%% Add the four Adventurer processes to this definition

%%% TODO (Exercise 5):
%%% Add the Referee process to this definition